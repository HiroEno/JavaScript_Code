// glossaryファイル JavaScript_Code
`use strict`
const glossary = [
{target:`const`, content:`定数を宣言するためのキーワード。<br>ブロックスコープを持つ。<br>*** name = value;<br>*** element = 'Apple';`},
{target:`let`, content:`変数を宣言するためのキーワード。<br>ブロックスコープを持つ。<br>*** name = value;<br>*** element = 42;`},
{target:`var`, content:`非推奨。変数を宣言するためのキーワード。<br>再宣言が可能。<br>*** name = value;<br>*** element = '42';`},
{target:`if`, content:`条件文を表現するためのキーワード。<br>条件が真の場合にコードを実行。<br>*** (condition) {};<br><br>*** () {<br>} else *** () {<br>} else {<br>};`},
{target:`else`, content:`if文の条件が偽の場合に実行されるブロックを指定するためのキーワード。<br>} *** {};<br><br>if(){<br>}*** if(){<br>} *** {<br>};`},
{target:`else if`, content:`if文の条件が偽で、さらなる条件を検証するためのキーワード。<br>} *** *** (condition) {};<br><br>if(){<br>}*** ***(){<br>} else {<br>};`},
{target:`function`, content:`指定された引数を使用して関数を定義するためのキーワード。<br>*** name (param)  {<br>&emsp;statements<br>};<br>*** square(x) {<br>&emsp;return x * x;<br>};`},
{target:`return`, content:`関数の実行を終了して、関数の呼び出し元に返す値を指定するためのキーワード。<br>*** expression;<br>function square(x) {<br>&emsp;*** x * x;<br>};`},
{target:`for`, content:`ループ構造を表現するためのキーワード。<br>指定された条件で繰り返し処理を行う。<br>*** (initialization; condition; afterthought) {<br>&emsp;statement<br>};<br>***  (const key in obj) {<br>};<br>*** (const elem of array) {<br>};<br>*** (const index in array) {<br>};<br>*** (let i = 0; i < 9; i++) {<br>};`},
{target:`while`, content:`ループ構造を表現するためのキーワード。<br>指定された条件が真の場合にコードを実行し、条件が偽になるまで繰り返す。<br>*** (condition) {<br>&emsp;statement<br>};<br>let n = 0;<br>*** (n < 3) {<br>&emsp;n++;<br>};`},
{target:`typeof`, content:`データ型を返す演算子。<br>*** operand;<br>*** 42; → 'number'`},
{target:`Number()`, content:`数値型オブジェクトを生成します。<br>関数として呼び出された場合は、数値型のプリミティブ値を返すコンストラクター。<br>***('123'); → 123`},
{target:`String()`, content:`文字列オブジェクトを生成します。<br>関数として呼び出された場合は、文字列型のプリミティブ値を返すコンストラクター。<br>***(123); → '123'`},
{target:`Function()`, content:`関数オブジェクトを生成するコンストラクター。<br>コンストラクターを直接呼び出すと動的に関数を生成することができる。グローバルスコープで実行される関数のみを生成。<br>const sum = new ***('a', 'b', 'return a + b');<br>sum(2, 6); → 8`},
{target:`parseInt()`, content:`文字列の引数を解釈し、指定された基数 （数学的記数法の底）の整数値を返す関数。<br>***('123.123'); → 123`},
{target:`parseFloat()`, content:`引数を (必要に応じてまず文字列に変換してから) 解釈し、浮動小数点値を返す関数。<br>***('123.123'); → 123.123`},
{target:`.concat()`, content:`二つの配列を結合するメソッド。<br>新しい配列を返す。<br>array1.***(array2);<br>array3 = array1.***(array2); → array3 = [...array1, ...array2];（スプレッド構文と同様の働き）`},
{target:`.filter()`, content:`配列の要素をフィルタリングするためのメソッド。<br>テストに合格した要素だけを抽出したシャローコピーの配列を作成する。使用するcallbackFnは引数に要素、インデックス、配列を受け取れる。<br>array.***(callbackFn);<br>const array = [12, 5, 8, 5, 130, 12, 44];<br>array.***((x) => x > 10); → [12, 130, 12, 44]<br><br>★array.***((elem, index, array) => array.indexOf(elem) === index); → [12, 5, 8, 130, 44]（ユニークな要素を抽出）`},
{target:`.forEach()`, content:`配列の各要素に対して指定された関数を実行するメソッド。<br>array.***(callbackFn);<br>array.***((element) => console.log(element));<br>const elements = document.getElementsByTagName('h1');<br><br>★Array.from(elements).***(x => console.log(x)); → HTMLのh1タグを順番にコンソールに表示`},
{target:`.map()`, content:`配列の各要素に対して指定された関数を適用するメソッド。<br>新しい配列を返す。オブジェクトの配列を受け取るときキーを受け取れる。<br>array.***(callbackFn);<br>array.***((x) => x * 2);<br>const objArray = [<br>&emsp;{key: 'A', value: 1},<br>&emsp;{key: 'B', value: 2},<br>&emsp;{key: 'C', value: 3},<br>];<br>const array = objArray.map(({key, value}) => ({[key]: value})); → [{'A': 1}, {'B': 2}, {'C': 3}]`},
{target:`.length`, content:`要素の数や文字数を調べるプロパティ。<br>配列オブジェクトはこのプロパティを監視し、自動的にこの値を配列のコンテンツと同期させ、新しい値を超えた要素は削除される。また、lengthに現在の長さ以上の値を設定すると疎配列を作成する。これを利用すると連番を生成できる。<br>array.***; → 要素数<br>'abc'.***; → 3<br>const numbers = [];<br>numbers.*** = 3;<br>console.log(numbers); → [empty × 3]（疎配列）<br><br>★const range = (start, stop, step) =><br>&emsp;Array.from({length: (stop - start) / step + 1}, (_, i) => start + i * step); → 連番関数<br>range(0, 4, 1); → [0, 1, 2, 3, 4]<br>range(1, 10, 2); → [1, 3, 5, 7, 9]`},
{target:`.at()`, content:`整数値を受け取り、その位置にある項目を返すメソッド。<br>負の整数は、配列の最後の項目から前へ数え項目を返す。<br>array.***(index);<br>const array = [5, 12, 8, 130, 44];<br>array.***(2); → 8<br>array.***(-2); → 130`},
{target:`.pop()`, content:`配列の最後の要素を削除するメソッド。<br>array.***();<br>const array = [5, 12, 8, 130, 44];<br>array.***(); → 44, array → [5, 12, 8, 130]`},
{target:`.push()`, content:`配列の最後に要素を加えるメソッド。<br>array.***(element);<br>const array = [5, 12, 8, 130, 44];<br>array.***(100); → [5, 12, 8, 130, 44, 100]`},
{target:`.shift()`, content:`配列から最初の要素を取り除き、その要素を返すメソッド。<br>配列の長さを変える。<br>const array = [1, 2, 3];<br>const first = array.***(); → array → [2, 3], first → 1`},
{target:`.unshift()`, content:`配列の最初に要素を加えるメソッド。<br>array.***(element);<br>const array = [5, 12, 8, 130, 44];<br>array.***(100); → [100, 5, 12, 8, 130, 44]`},
{target:`.reverse()`, content:`配列の要素を反転させ、その配列への参照を返すメソッド。<br>元の配列を変更せずに配列の要素を反転させるには toReversed() を使用。<br>array.***();`},
{target:`.sort()`, content:`配列の要素をソートし、ソートされた同じ配列の参照を返すメソッド。<br>既定のソート順は昇順で、要素を文字列に変換してから、UTF-16 コード単位の値の並びとして比較。元の配列を変更せずに配列内の要素をソートするには、toSorted() を使用。関数を使用する場合、aとbの2値を引数とし、例えば降順の場合、aが大きい場合は負の、aが小さい場合は正の、同じ場合は0を返すように関数を作る。<br>array.***();<br>array.***(compareFn(a, b));<br><br>★const func = (a, b) => {return a - b}; → 昇順にソート<br>★const func = (a, b) => {return b - a}; → 降順にソート<br>const array = ['80', '9', '700', 40, 1, 5, 200];<br>array.***(); → [1, 200, 40, 5, '700', '80', '9']<br>array.***(func); → ['700', 200, '80', 40, '9', 5, 1]<br>★array.***((a, b) => b - a)[0]; → 最大値<br>★array.***((a, b) => a - b)[0]; → 最小値`},
{target:`.slice()`, content:`配列の一部を start から end （end は含まれない）までの範囲で、選択した新しい配列オブジェクトにシャローコピーして返すメソッド。 元の配列は変更されない。<br>array.***(start, end);<br>const array = [1, 2, 3, 4, 5];<br>array.***(2, 4); → [3, 4]<br><br>★array.***(); → シャローコピー、[...array]と同様`},
{target:`.splice()`, content:`配列の既存の要素を取り除いたり（削除）、置き換えたり（置換）、新しい要素を追加するメソッド。<br>array.***(start, deleteCount, item1);<br>const months = ['Jan', 'fed', 'March', 'April', 'June'];<br>months.***(1, 1, 'Feb'); → ['Jan', 'Feb', 'March', 'April', 'June']<br><br>★for (let i = 0; i < array.length; i++) {→ 特定要素の削除<br>&emsp;if (JSON.stringify(array[i]) === JSON.stringify(delete)) {<br>&emsp;&emsp;array.***(i, 1);<br>&emsp;}<br>};`},
{target:`.split()`, content:`文字列を指定の区切りで分割するメソッド。<br>('')で1文字ずつ分割。<br>'apple,orange,banana'.***(','); → ['apple', 'orange', 'banana']<br>'str'.***(''); → ['s', 't', 'r']<br><br>★words.***(' ').length; → 単語数をカウント<br>★word.***('').filter(x => ['a', 'i', 'u', 'e', 'o'].includes(x.toLowerCase())).length; → 母音数をカウント`},
{target:`.copyWithin()`, content:`この配列の一部を配列内の他の場所にシャローコピーし、この配列の長さを変更せず返すメソッド。<br>array.***(targetIndex, startIndex, endIndex);<br>const array = ['a', 'b', 'c', 'd', 'e'];<br>array.***(1, 2, 4); → ['a', 'c', 'd', 'd', 'e']`},
{target:`.entries()`, content:`配列内の各要素に対するキー/値のペアを含む新しい配列イテレーターオブジェクトを返すメソッド。元の配列は変更しない。<br>array.***();<br>const array = ['a', 'b', 'c'];<br>array.***() → {[0, 'a'], [1, 'b'], [2, 'c']};`},
{target:`.every()`, content:`配列のそれぞれの要素に対して、指定されたcallbackFn関数が偽値を返すまで一度ずつ呼び出すメソッド。<br>そのような要素が見つかった場合、every()は直ちにfalseを返し、配列の反復処理を中止する。そうでない場合、callbackFnがすべての要素に対して真値を返すと、every()はtrueを返す。<br>array.***(callbackFn);<br>const overTen = (element) => element > 10;<br>[12, 5, 8, 130, 44].***(overTen); → false<br>[12, 54, 18, 130, 44].***(overTen); → true`},
{target:`.fill()`, content:`インデックスの範囲内にある配列のすべての要素を一定の値に変更するメソッド。<br>array.***(value, startIndex, endIndex);<br>const array = [1, 2, 3, 4, 5];<br>array.fill(10, 2, 4); → [1, 2, 10, 10, 5]`},
{target:`.find()`, content:`提供されたテスト関数を満たす配列内の最初の要素を返すメソッド。<br>テスト関数を満たす値がない場合は undefined を返す。<br>const array = [5, 12, 8, 130, 44];<br>const found = array.***((element) => element > 10); → 12`},
{target:`.findIndex()`, content:`配列内の指定されたテスト関数に合格する最初の要素のインデックスを返すメソッド。<br>テスト関数に合格する要素がなかった場合は -1 を返す。<br>const array = [5, 12, 8, 130, 44];<br>const found = array.***((element) => element > 13); → 3`},
{target:`.findLast()`, content:`配列を逆順に反復処理し、提供されたテスト関数を満たす最初の要素を返すメソッド。<br>テスト関数を満たす値がない場合は undefined を返す。<br>const array = [5, 12, 8, 130, 44];<br>const found = array.***((element) => element > 100); → 130`},
{target:`.findLastIndex()`, content:`配列を逆順に反復処理し、テスト関数に合格する最初の要素のインデックスを返すメソッド。<br>テスト関数に合格する要素がなかった場合は -1 を返す。<br>const array = [5, 12, 8, 130, 44];<br>const found = array.***((element) => element > 100); → 3`},
{target:`.flat()`, content:`すべてのサブ配列の要素を指定した深さで再帰的に結合した新しい配列を生成するメソッド。<br>***(depth);<br>const array = [0, 1, [2, [3, [4, 5]]]];<br>array.***(2); → [0, 1, 2, 3, [4, 5]]`},
{target:`.flatMap()`, content:`最初にマッピング関数を使用してそれぞれの要素をマップした後、結果を新しい配列内に平坦化するメソッド。<br>const arr = [1, 2, 3];<br>const result = arr.***((num) => (num === 2 ? [2, 2] : 4)); → [4, 2, 2, 4]`},
{target:`.includes()`, content:`特定の要素が配列に含まれているかどうかをtrueまたはfalseで返すメソッド。<br>array.***(searchElement, fromIndex);<br>const array = [1, 2, 3];<br>array.***(2); → true<br>★Object.keys(object).***(key); → objectのキーにkeyが存在するか判別。'key in object'と同じ`},
{target:`.indexOf()`, content:`引数に与えられた内容と同じ内容を持つ最初の配列要素の添字を返すメソッド。<br>存在しない場合は -1 を返す。<br>const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];<br>beasts.***('bison'); → 1`},
{target:`.join()`, content:`配列の全要素を順に連結した新しい文字列を返すメソッド。<br>区切り文字はカンマ、または指定された文字列。配列に要素が一つしかない場合は、区切り文字を使用せずに要素が返される。<br>const elements = ['Fire', 'Air', 'Water'];<br>elements.***('-'); → 'Fire-Air-Water'`},
{target:`.keys()`, content:`配列内の各インデックスのキーを含む、新しい配列イテレーターオブジェクトを返すメソッド。<br>array.***();`},
{target:`.lastIndexOf()`, content:`配列中で与えられた要素が見つかった最後の添字を返すメソッド。<br>存在しなければ -1 を返す。配列は fromIndex から逆向きに検索される。<br>const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];<br>animals.***('Dodo'); → 3`},
{target:`.reduce()`, content:`配列のそれぞれの要素に対して、「縮小」コールバック関数を呼び出し、直前の要素での計算結果の返値を渡すメソッド。<br>配列の全要素に対して縮小関数を実行した結果を返す。コールバックの初回実行時は初期値（指定の無い場合は0）が使用され、次の要素から反復処理が開始される。縮小関数に((a, b) => a + b)を宣言すると配列の合計値が返される。また、accumulatorに配列を利用する時はinitialValueに空配列を指定する。<br>array.***(callbackFn, initialValue);<br>const array = [1, 2, 3, 2, 4];<br>const initialValue = 0;<br>const sumWithInitial = array.***((accumulator, currentValue) => accumulator + currentValue,  initialValue); → sumWithInitial → 13<br>array.***((a, b) => a + b); → 12<br>array.***((a, b) => a * b); → 48<br>array.***((a, b)=> a - b, 5); → -7<br><br>★array.***((accum, num) =>{<br>&emsp;accum.includes(num) ? null: accum.push(num);<br>&emsp;return accum;<br>}, []); → [1, 2, 3, 4]（ユニークな要素を抽出）<br>★Array.from(word).reverse().***((a, b) => a + b); → 文字列を逆順<br>★array.***((a, b) => [...a, ...b]); 多次元配列をフラット化<br>★words.split(' ').***((a, b) => a[0].toUpperCase() + a.slice(1) + ' ' + b[0].toUpperCase() + b.slice(1)); → 各単語の最初の文字を大文字にする<br>★array.***((a, b) => {a.includes(b) ? NaN: a.push(b); return a;}, []); → 配列内の重複する要素を削除する`},
{target:`.reduceRight()`, content:`アキュームレーターと配列のそれぞれの値に対して（右から左へ）関数を適用して、単一の値を返すメソッド。<br>左から右へ適用する場合は.reduce() を参照。<br>array.***(callbackFn, initialValue);<br>const array = [[0, 1], [2, 3], [4, 5],];<br>const result = array.***((accumulator, currentValue) =><br>&emsp;accumulator.concat(currentValue);<br>);<br>result → [4, 5, 2, 3, 0, 1]`},
{target:`.some()`, content:`指定された関数で実装されているテストに、配列の中の少なくとも1つの要素が合格するかどうかを判定するメソッド。<br>配列の中で指定された関数が true を返す要素を見つけた場合は true を返し、そうでない場合は false を返す。それ以外の場合は false を返す。<br>array.***(callbackFn);<br>const array = [1, 2, 3, 4, 5];<br>array.***((x) => x % 2 === 0); → true`},
{target:`.values()`, content:`配列の各インデックスの値を含む新しい配列イテレーターオブジェクトを返すメソッド。<br>array.***();`},
{target:`.with()`, content:`ブラケット記法に対応するコピーメソッド。<br>指定された位置の要素を指定された値で置き換えた新しい配列を返す。<br>arrayInstance.***(index, value);<br>const array = [1, 2, 3, 4, 5];<br>array.***(2, 6); → [1, 2, 6, 4, 5], array → [1, 2, 3, 4, 5]`},
{target:`.toReversed()`, content:`要素を逆順に並べた新しい配列を返すメソッド。<br>const array = [1, 2, 3];<br>const newArray = array.***() → [3, 2, 1];`},
{target:`.toLocaleString()`, content:`配列の要素を表す文字列を返すメソッド。<br>引数localesとoptionsを指定して呼び出し、実装で定義された区切り文字 (',') でその結果を連結したものを返す。<br>const array = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')];<br>const localeString = array.***('en', {timeZone: 'UTC'}); → '1,a,12/21/1997, 2:12:00 PM'<br>const prices = ['￥7', 500, 8123, 12];<br>prices.***('ja-JP', {style: 'currency', currency: 'JPY'}); → '￥7,￥500,￥8,123,￥12' `},
{target:`.toSorted()`, content:`.sort() メソッドに対応するコピーメソッド。<br>要素を昇順にソートした新しい配列を返す。<br>const values = [1, 10, 21, 2];<br>const sortedValues = values.***((a, b) => a - b); → sortedValues → [1, 2, 10, 21], values → [1, 10, 21, 2]`},
{target:`.toSpliced()`, content:`.splice() メソッドに対応するコピーメソッド。<br>指定された位置の要素を除去（削除）したり置き換えたり（置換）した新しい配列を返す。<br>array.***(startIndex, deleteCount, item1, item2);<br>const months = ['Jan', 'Feb', 'May'];<br>const monthsRevised = months.***(1, 1, 'Mar', 'Apr'); → monthsRevised → ['Jan', 'Mar', 'Apr', 'May'], months → ['Jan', 'Feb', 'May']　元配列はそのまま`},
{target:`.toString()`, content:`指定された配列とその要素を表す文字列を返すメソッド。<br>const array = [1, 2, 'a', '1a'];<br>array.***(); → '1,2,a,1a'`},
{target:`Array()`, content:`配列オブジェクトを生成するコンストラクター。<br>スプレッド構文と組合せることでn個のundefinedからなる新しい配列を作成できる。これと.forEach等を組合せることでn回の繰り返し作業が可能（空はスキップされるためスプレッド構文による展開が必要）。<br>***('りんご', 'バナナ'); → ['りんご', 'バナナ']<br><br>★[...***(3)]; → [undefined, undefined, undefined]<br>★[...***(3)].forEach(() => console.log('Hello')); → 'Hello'を3回表示 `},
{target:`Array.from()`, content:`反復可能オブジェクトや配列風オブジェクトからシャローコピーされた、新しいArrayインスタンスを生成する静的メソッド。<br>HTML要素の処理に使える。<br>const array = [1, 2, 3];<br>const copyArray = ***.***(array);<br>copyArray.pop();<br>const newArray = ***.***(array, x => x * 2);<br>array → [1, 2, 3], copyArray → [1, 2], newArray → [2, 4, 6]<br>***.***('foo'); → ['f', 'o', 'o']<br><br>★const elements = document.getElementsByTagName('h1');<br>***.***(elements).forEach(x => console.lg(x)); → HTMLのh1タグを順番にコンソールに表示`},
{target:`Array.isArray()`, content:`渡された値が配列かどうかを判断する静的メソッド。<br>***.***([1, 3, 5]); → true<br>***.***('[]')); → false`},
{target:`Array.of()`, content:`引数の数や型にかかわらず、可変長引数から新しい配列インスタンスを生成する静的メソッド。<br>const array = ***.***('foo', 2, 'bar', true); → ['foo', 2, 'bar', true]`},
{target:`Object.assign()`, content:`すべての列挙可能な自身のプロパティの値を、1つ以上のコピー元オブジェクトからコピー先オブジェクトにコピーするために使用するメソッド。<br>変更されたコピー先オブジェクトを返す。ターゲットに空のオブジェクトを指定することで、新たなオブジェクトにオブジェクトのコピーを作れる。<br>***.***(target, ...sources);<br>const target = {a: 1, b: 2};<br>const source = {b: 4, c: 5};<br>const returnedTarget = ***.***(target, source); → target → {a: 1, b: 4, c: 5}, returnedTarget → {a: 1, b: 4, c: 5}, source → {b: 4, c: 5}<br><br>★const copyObj = ***.***({}, source); → copyObj → {b: 4, c: 5}（新しいオブジェクトコピー）`},
{target:`Object.keys()`, content:`指定されたオブジェクトが持つプロパティのキーの配列を取得するメソッド。<br>通常のループで取得するのと同じ順序で返す。これによりオブジェクトのキーを対象とした配列のメソッドを利用可能になる。<br>***.***(obj);<br>const object = {a: 'somestring', b: 42, c: false,};<br>***.***(object); → ['a', 'b', 'c']<br>★***.***(object).includes(key); → objectのキーにkeyが存在するか判別。'key in object'と同じ`},
{target:`Object.values()`, content:`指定されたオブジェクトが持つ列挙可能なプロパティの値を取得するメソッド。<br>for...in ループで提供される場合と同じ順序で配列にして返す。これによりオブジェクトの値を対象とした配列のメソッドを利用可能になる。<br>***.***(obj);<br>const object = {a: 'somestring', b: 42, c: false,};<br>***.***(object); → ['somestring', 42, false]`},
{target:`Object.groupBy()`, content:`指定されたコールバック関数によって返された文字列値に従って、指定された反復可能な要素をグループ化する静的メソッド。<br>返されるオブジェクトには、グループごとに個別のプロパティがあり、グループ内の要素を含む配列が格納。<br>***.***(items, callbackFn);<br>const inventory = [<br>&emsp;{name: 'asparagus', type: 'vegetables', quantity: 5},<br>&emsp;{name: 'bananas', type: 'fruit', quantity: 0},<br>&emsp;{name: 'goat', type: 'meat', quantity: 23},<br>&emsp;{name: 'cherries', type: 'fruit', quantity: 5},<br>&emsp;{name: 'fish', type: 'meat', quantity: 22},<br>};<br>const result = ***.***(inventory, ({type}) => type);<br>&emsp;result → {vegetables: [{name: 'asparagus', type: 'vegetables', quantity: 5},],<br>&emsp;fruit: [{name: 'bananas', type: 'fruit', quantity: 0},<br>&emsp;&emsp;{name: 'cherries', type: 'fruit', quantity: 5}],<br>&emsp;meat: [{name: 'goat', type: 'meat', quantity: 23},<br>&emsp;&emsp;{name: 'fish', type: 'meat', quantity: 22}]}`},
{target:`.toString()`, content:`値を文字列に変換するメソッド。<br>let num = 42;<br>num.***(); → '42'`},
{target:`.toLowerCase()`, content:`文字列を小文字に変換するメソッド。<br>'Hello'.***(); → 'hello'`},
{target:`.toUpperCase()`, content:`文字列を大文字に変換するメソッド。<br>'hello'.***(); → 'HELLO'`},
{target:`.startsWith()`, content:`文字列が引数で指定された文字列で始まるかを判定してtrueかfalseを返すメソッド。<br>***(searchString, endPosition);<br>const str = 'Saturday night plans';<br>str.***('Sat'); → true<br>str.***('Sat', 3); → false;`},
{target:`.endsWith()`, content:`文字列が引数で指定された文字列で終わるかを判定してtrueかfalseを返すメソッド。<br>***(searchString, endPosition);<br>const str = 'Saturday night plans';<br>str.***('plans'); → true<br>str.***('plans', 20); → true;`},
{target:`.includes()`, content:`1 つの文字列が別の文字列の中に含まれるかを判断し、trueかfalseを返すメソッド。<br>***(searchString, position);<br>'Blue Whale'.***('Blue'); → true<br>'Blue Whale'.***('Blue', 1); → false<br>'Blue Whale'.***('blue'); → false<br>'Blue Whale'.toLowerCase().***('blue'); → true`},
{target:`.indexOf()`, content:`この文字列を検索し、指定した部分文字列が最初に出現するインデックスを返すメソッド。<br>***(searchString, position);<br>'Blue Whale'.***('Blue'); → 0<br>'Blue Whale'.***('Whale', 0); → 5<br>'Blue Whale'.**:('Whale', 7); → -1<br>'Blue Whale'.***('', 11); → 10`},
{target:`.padEnd()`, content:`結果の文字列が指定した長さになるように、現在の文字列を他の文字列で（必要に応じて繰り返して）延長するメソッド。<br>延長は、現在の文字列の末尾から適用される。<br>***(targetLength, padString);<br>const str = 'Bread';<br>str.***(10, '.')); → 'Bread.....'`},
{target:`.padStart()`, content:`結果の文字列が指定した長さになるように、現在の文字列を他の文字列で（必要に応じて繰り返して）延長するメソッド。<br>延長は、現在の文字列の最初から適用される。<br>***(targetLength, padString);<br>const str = 'Bread';<br>str.***(10, '.')); → '.....Bread'`},
{target:`.repeat()`, content:`呼び出し元の文字列を指定した数だけコピーして結合した新しい文字列を構築して返すメソッド。<br>const mood = 'Happy! ';<br>***.repeat(3); → 'Happy! Happy! Happy! '`},
{target:`.replace()`, content:`pattern に一致する文字列の一部またはすべてをreplacementで置き換えた新しい文字列を返すメソッド。<br>***(pattern, replacement);<br>'foof'.***('f', 'A'); → 'Aoof'<br>★'Abc 123!!456'.***(/[^A-Za-z0-9&yen;s]+/g, ' '); → 'Abc 123456' 大文字、小文字、数字、スペース以外の文字をスペースに変換<br>★text.***(/&yen;s+/g, ' '); → 1つ以上連続する空白文字（改行、タブ、スペースなど）をスペースに変換`},
{target:`.replaceAll()`, content:`pattern に一致したすべての文字列をreplacementで置き換えた新しい文字列を返すメソッド。<br>***(pattern, replacement);<br>'foof'.***('f', 'A'); → 'AooA'`},
{target:`.search()`, content:`正規表現とこの文字列オブジェクトが一致するかどうかを調べるメソッド。<br>***(regexp);<br>'hey JudE'.***(/[A-Z]/); → 4<br>'hey JudE'['hey JudE'.***(/[A-Z]/)]; → 'J'`},
{target:`.slice()`, content:`元の文字列を変更せず、文字列の一部分を取り出し、それを新しい文字列として返すメソッド。<br>***(indexStart, indexEnd);<br>const str = 'The quick brown fox jumps over the lazy dog.';<br>str.slice(31); → 'the lazy dog.', <br>str.slice(4, 19); → 'quick brown fox'<br>str.slice(-4); → 'dog.'<br>str.slice(-9, -5); → 'lazy'`},
{target:`.split()`, content:`パターンを受け取り、文字列をパターン検索によって部分文字列の順序付きリストに分割し、これらの部分文字列を配列に入れ、その配列を返すメソッド。<br>***(separator, limit);<br>const str = 'The quick brown fox';<br>str.***(' '); → ['The', 'quick', 'brown', 'fox']<br>str.***(' ', 3); → ['The', 'quick', 'brown']`},
{target:`.substring()`, content:`文字列の一部、開始インデックスから終了インデックスの手前まで、または終了インデックスが指定されなかった場合は文字列の最後までを返すメソッド。<br>***(indexStart, indexEnd);<br>const str = 'Mozilla';<br>str.***(1, 3); → 'oz'<br>str.***(2); → 'zilla'`},
{target:`.trim()`, content:`文字列の両端からホワイトスペースを取り除き、元の文字列を変更せずに新しい文字列を返すメソッド。<br>const greeting = '   Hello world!   ';<br>greeting.***(); → 'Hello world!'`},
{target:`.trimEnd()`, content:`元の文字列を変更せずに、文字列の末尾のホワイトスペースを削除した新しい文字列を返すメソッド。<br>const greeting = '   Hello world!   ';<br>greeting.***(); → '   Hello world!'`},
{target:`.trimStart()`, content:`元の文字列を変更せずに、文字列の先頭のホワイトスペースを削除した新しい文字列を返すメソッド。<br>const greeting = '   Hello world!   ';<br>greeting.***(); → 'Hello world!   '`},
{target:`.valueOf()`, content:`文字列オブジェクトのプリミティブ値を返すメソッド。<br>const stringObj = new String('foo');<br>stringObj.***(); → 'foo'`},
{target:`Math.abs()`, content:`数値の絶対値を返す関数。<br>***.***(x); → |x|`},
{target:`Math.pow()`, content:`数の累乗を計算する関数。<br>***.***(2, 3); → 8`},
{target:`Math.random()`, content:`0以上1未満 (0は含むが、1は含まない) の範囲で浮動小数点の擬似乱数を返す関数。<br>***.***();`},
{target:`Math.round()`, content:`引数として与えた数を四捨五入して、もっとも近似の整数を返す関数。<br>***.***(0.9); → 1`},
{target:`Math.ceil()`, content:`引数として与えた数以上の最小の整数を返す関数。<br>***.***(0.95); → 1`},
{target:`Math.floor()`, content:`与えられた数値以下の最大の整数を返す関数。<br>***.***(1.2); → 1`},
{target:`Math.trunc()`, content:`引数として与えた数の小数部の桁を取り除くことによって整数部を返す関数。<br>***.***(13.3); → 13<br>***.***(-12.3); → -12`},
{target:`Math.sign()`, content:`引数として渡された数値の符号が正か負かを表す+/- 1を返す関数。<br>渡された数が0であれば、+/- 0を返す。数値が正である場合、明示的な (+) は返さない。<br>***.***(3); → 1`},
{target:`Math.max()`, content:`入力引数として与えられた0個以上の数値のうち最大の数を返す関数。<br>***.***(1, 3, 2); → 3<br>let arr = [1, 2, 3];<br><br>★***.***(...arr); → 3<br>★***.***.apply(null, arr); → 3`},
{target:`Math.min()`, content:`引数で渡されたもののうち最小の値を返す関数。<br>***.***(2, 3, 1); → 1<br>let arr = [1, 2, 3];<br><br>★***.***(...arr); → 1<br>★***.***.apply(null, arr); → 1`},
{target:`Math.hypot()`, content:`各引数の二乗の合計値の平方根を返す関数。<br>***.***(3, 4); → 5`},
{target:`Math.sqrt()`, content:`ある数の平方根を返す関数。<br>***.***(4); → 2`},
{target:`Math.PI`, content:`円周と直径の比率を表すプロパティ。`},
{target:`.toFixed()`, content:`数を固定小数点表記を用いて整形するメソッド。<br>123.456789.***(3); → '123.456'`},
{target:`Number.isInteger()`, content:`整数かどうかを判定する静的メソッド。<br>***.***(42.5); → false`},
{target:`Number.parseFloat()`, content:`引数を解釈して浮動小数点値を返す静的メソッド。<br>***.***('42.5'); → 42.5`},
{target:`Number.parseInt()`, content:`文字列の引数を解釈し、指定された基数の整数値を返す静的メソッド。<br>***.***('42.5'); → 42`},
{target:`break`, content:`ループやswitch文から抜けるためのキーワード。<br>***;`},
{target:`continue`, content:`ループの次の繰り返しに進むためのキーワード。<br>***;`},
{target:`debugger`, content:`プログラムの実行を一時停止し、デバッガの実行を可能にする。<br>***;`},
{target:`delete`, content:`オブジェクトからプロパティを削除する演算子。<br>*** expression;`},
{target:`finally`, content:`try文のブロックが終了した後に実行されるブロック。<br>try {tryStatements} catch (exceptionVar) {catchStatements} *** {finallyStatements}`},
{target:`nan`, content:`オブジェクトが指定されたプロパティ（キー）を持っているかをチェックする演算子。<br>key *** object;<br>★const car = {make: 'TOYOTA', model: 'Prius', year: 1997};<br>'make' in car; → true<br>'TOYOTA' in car; → false`},
{target:`instanceof`, content:`オブジェクトが指定されたクラスのインスタンスであるかをチェックする演算子。<br>object *** constructor;`},
{target:`switch`, content:`式を評価して、一連のcase節に対してその式の値を照合し、最初に値が一致したcase節の後の文を、break文に出会うまで実行。<br>一致したcase の後にある文も同様に実行。default節には、caseが式の値と一致しない場合にジャンプする。<br>*** (expression) {case value1: 文 case value2: 文 // … case valueN: 文 default: 文}<br>const foo = 0;<br>switch (foo) {<br>&emsp;case -1:<br>&emsp;&emsp;break;<br>&emsp;case 0:<br>&emsp;&emsp;console.log(0);<br>&emsp;case 1:<br>&emsp;&emsp;console.log(1);<br>&emsp;&emsp;break;<br>&emsp;case 2:<br>&emsp;&emsp;console.log(2);<br>&emsp;default:<br>&emsp;&emsp;console.log('default');<br>} → 0, 1が順次コンソールに表示`},
{target:`class`, content:`この宣言によりプロトタイプベースの継承を使って、指定された名前の新しいクラスを作成。<br>*** name [extends otherName] {'クラス本体'}<br><br>*** ClassName {<br>&emsp;constructor(name) {<br>&emsp;&emsp;this.name = name;<br>&emsp;}<br>&emsp;firstProperty = 'Type';<br>&emsp;secondProperty = 10;<br>&emsp;firstMethod() {<br>&emsp;&emsp;console.log(this.name, this.secondProperty);<br>&emsp;}<br>}<br><br>const instance = new ClassName('example'); → ()内の'example'はコンストラクターの引数<br>console.log(instance.name); → 'example'<br>console.log(instance.firstProperty); → 'type'<br>instance.firstMethod(); → example 10`},
{target:`constructor`, content:`クラスで作成されたオブジェクトインスタンスの生成と初期化を行うための特殊なメソッド。<br>class Polygon {<br>&emsp;***() {<br>&emsp;&emsp;this.name = 'Polygon';<br>&emsp;}<br>}<br><br>class ClassName {<br>&emsp;***(name) {<br>&emsp;&emsp;this.name = name;<br>&emsp;}<br>&emsp;firstProperty = 'Type';<br>&emsp;secondProperty = 10;<br>&emsp;firstMethod() {<br>&emsp;&emsp;console.log(this.name, this.secondProperty);<br>&emsp;}<br>}`},
{target:`this`, content:`オブジェクト自体を指すキーワード。<br>class ClassName {<br>&emsp;constructor(name) {<br>&emsp;&emsp;***.name = name;<br>&emsp;}<br>&emsp;firstProperty = 'Type';<br>&emsp;secondProperty = 10;<br>&emsp;firstMethod() {<br>&emsp;&emsp;console.log(***.name, ***.secondProperty);<br>&emsp;}<br>}`},
{target:`bind`, content:`新しい関数を生成するメソッド。<br>渡された引数、thisの値と最初のいくつかの引数を内部の状態として格納することで、thisを固定できる。アロー関数はbindと同様の効果を発揮し、実行時のコンテキストを固定化する。<br>const module = {<br>&emsp;x: 42,<br>&emsp;getX: function () {<br>&emsp;&emsp;return this.x;<br>&emsp;},<br>};<br>const unboundGetX = module.getX;<br>console.log(unboundGetX());  → undifined<br>const boundGetX = unboundGetX.***(module);<br>console.log(boundGetX()); → 42`},
{target:`new`, content:`インスタンスを生成するための演算子。<br>()内はコンストラクターに引き渡す引数。<br>class ClassName {<br>&emsp;constructor(name) {<br>&emsp;&emsp;this.name = name;<br>&emsp;}<br>&emsp;firstProperty = 'Type';<br>&emsp;secondProperty = 10;<br>&emsp;firstMethod() {<br>&emsp;&emsp;console.log(this.name, this.secondProperty);<br>&emsp;}<br>}<br>const newClass = *** ClassName('newClass'); → ()内の'newClass'はコンストラクターの引数`},
{target:`extends`, content:`クラス宣言やクラス式の中で、他のクラスの子であるクラスを生成するために使用するキーワード。<br>class ChildClass *** ParentClass {...}<br><br>class ClassName {<br>&emsp;constructor(name) {<br>&emsp;&emsp;this.name = name;<br>&emsp;}<br>&emsp;firstProperty = 'Type';<br>&emsp;secondProperty = 10;<br>&emsp;firstMethod() {<br>&emsp;&emsp;console.log(this.name, this.secondProperty);<br>&emsp;}<br>}<br>class CopyClass *** ClassName {<br>&emsp;firstProperty = 'Symbol';<br>}`},
{target:`throw`, content:`例外を発生させるためのキーワード。<br>*** expression;`},
{target:`try`, content:`例外を試みるためのブロック。<br>*** {tryStatements} catch (exceptionVar) {catchStatements} finally {finallyStatements}<br>*** {<br>&emsp; nonExistentFunction();<br>} catch (error) {<br>&emsp;console.error(error);<br>} → errorが表示`},
{target:`catch`, content:`try文で発生した例外を捕捉するためのブロック。<br>try {tryStatements} *** (exceptionVar) {catchStatements} finally {finallyStatements}<br>try {<br>&emsp;nonExistentFunction();<br>} *** (error) {<br>&emsp;console.error(error);<br>} → errorが表示`},
{target:`void`, content:`式を評価し、undefinedを返す演算子。<br>*** expression;`},
{target:`yield`, content:`ジェネレータ関数内で値を生成するためのキーワード。<br>[rv] = ***[expression];`},
{target:`super`, content:`サブクラスでスーパークラスのメソッドやプロパティにアクセスするためのキーワード。<br>***([arguments]); `},
{target:`.getElementsByTagName()`, content:`指定されたタグ名を持つ要素のHTMLCollectionを返すDOMメソッド。<br>document.***();`},
{target:`.getElementById()`, content:`idプロパティが指定された文字列に一致する要素を表すElementオブジェクトを返すDOMメソッド。<br>document.***();`},
{target:`.getElementsByClassName()`, content:`指定されたクラス名をすべて持つすべての子要素の配列風オブジェクトを返すDOMメソッド。<br>見つかった要素は生きたHTMLCollection。<br>document.***();`},
{target:`.getElementsByName()`, content:`文書内で指定したnameを持つ要素のNodeListコレクションを返すDocumentオブジェクト。<br>elementsは、生きたNodeListコレクションで文書内で同じnameを持った新しい要素が追加されたり削除されたりすると自動的に更新される。IE10 以前では指定されたid属性を持つ要素も返すため注意が必要。<br>document.***();`},
{target:`.querySelector()`, content:`指定されたセレクターまたはセレクター群に一致する、文書内の最初のElementを返すDOMメソッド。<br>一致するものが見つからない場合はnullを返す。<br>document.***(selectors);`},
{target:`.querySelectorAll()`, content:`指定されたCSSセレクターに一致する文書中の要素のリストを示す静的な（生きていない）NodeListを返すDOMメソッド。<br>document.***(selectors);`},
{target:`.forms`, content:`文書のすべてのformを列挙するHTMLCollectionオブジェクト。<br>コレクションのそれぞれの項目は、単一のform要素を表すHTMLFormElement。<br>const collection = document.***;<br>collection.length; → collection 内のアイテム数を返す。<br>collection.item(1); → リスト内の指定されたindex(先頭はゼロ) 位置にある特定のノードを返す。<br>collection.namedItem('Id'); → nameで指定した文字列にID、または代替としてnameが一致するノードを返す。<br><br>const select = document.***[1];<br>const selectElement = document.***[1].elements[0];<br>document.***['nameのプロパティ名'].elements['nameのプロパティ名'];`},
{target:`.createElement()`, content:`新しい要素を作成するDOMメソッド。<br>document.***();`},
{target:`.appendChild()`, content:`要素の末尾に子要素を追加するDOMメソッド。<br>element.***();<br><br>const newButton = document.createElement('button');<br>newIl.***(newButton); → リスト要素にボタンを追加<br>ulElement.***(newIl); → リスト要素を追加`},
{target:`.insertBefore()`, content:`要素の前に子要素を追加するDOMメソッド。<br>element.***();`},
{target:`.animate( , )`, content:`要素に対してアニメーションを適用するDOMメソッド。<br>element.***(keyframes, options);`},
{target:`.innerText`, content:`要素のテキストコンテンツを取得または設定するプロパティ。<br>スタイルを反映し、非表示の要素のテキストは返さず人間が読める要素のみを示す。<br>element.***;`},
{target:`.innerHTML`, content:`要素のHTMLコンテンツを取得または設定するプロパティ。<br>element.***;`},
{target:`.textContent`, content:`要素のテキストコンテンツを取得または設定するプロパティ。<br>scriptとstyle要素を含む、すべての要素の中身を取得。ノード内のすべての要素を返す。値がHTMLとして解析されないので性能が良くなる。また、XSS攻撃を防ぐことができる。<br>element.***;`},
{target:`.duration`, content:`アニメーションやメディアの時間長さを表すプロパティ。<br>element.***;`},
{target:`.className`, content:`要素のクラス名を取得または設定するプロパティ。<br>element.***;`},
{target:`.onclick`, content:`クリック時の動作のDOMメソッド。<br>element.*** = func;<br>element.*** = () => func(x);<br>element.*** = () => {};<br><br>element.*** = (event) => {};<br>eventの例: event.buttons, event.clientX, event.pageX, event.screenX, event.shiftKey etc`},
{target:`.classList`, content:`要素のクラス一覧を取得または設定するプロパティ。<br>element.***;`},
{target:`.remove()`, content:`要素を削除するDOMメソッド。<br>element.***();`},
{target:`.add()`, content:`要素への追加するDOMメソッド。<br>element.***();`},
{target:`.location.assign()`, content:`新しいURLへ移動するDOMメソッド。<br>window.***.***();`},
{target:`.removeEventListener`, content:`イベントリスナーの削除するDOMメソッド。<br>element.***(type, listener);`},
{target:`.removeChild()`, content:`子要素の削除するDOMメソッド。<br>document.***(child);`},
{target:`setTimeout()`, content:`一定時間後に指定された関数を実行するDOMメソッド。<br>***(code, delay);<br><br>★***(() => {<br>&emsp;&emsp;console.log('Delayed for 1 second.');<br>&emsp;}, '1000');<br>★***(() => {console.log('Hi!');}, 1000); → 1秒後に 'Hi!' をログに表示`},
{target:`location.reload()`, content:`現在のURLの再読み込みのDOMメソッド。<br>***.***();`},
{target:`setAttribute`, content:`指定された要素の属性の値を設定するDOMメソッド。<br>element.***('data', 'value'); → elementにdata属性を追加`},
{target:`add`, content:`要素にクラスを追加するDOMメソッド。<br>element.***(); → elementをDOMに追加`},
{target:`remove`, content:`要素を削除するDOMメソッド。<br>element.***(); → elementをDOMから削除`},
{target:`.addEventListener()`, content:`イベントリスナーを要素に追加するDOMメソッド。<br>リスナーには関数を指定。<br>element.***(type, listener);<br>element.*** = (type, () => func(x));<br>element.*** = (type, () => {});<br><br>element.*** = (type, (event) => {})<br>eventの例: event.buttons, event.clientX, event.pageX, event.screenX, event.shiftKey etc`},
{target:`keyup`, content:`キーボードのキーが上がったときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`keydown`, content:`キーボードのキーが押されたときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`keypress`, content:`キーボードのキーが押されたときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`click`, content:`要素がクリックされたときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`hover`, content:`要素にマウスが重なったときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`mouseenter`, content:`要素にマウスが入ったときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`mouseleave`, content:`要素からマウスが出たときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`mouseover`, content:`要素にマウスが乗ったときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`change`, content:`フォーム要素の値が変更されたときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`focus`, content:`要素がフォーカスを受け取ったときに発生するイベント。<br>element.addEventListener('***', listener);<br>element.addEventListener = ('***', () => func(x));<br>element.addEventListener = ('***', () => {});<br>element.addEventListener('***', (event) => {});`},
{target:`DOMContentLoaded`, content:`HTMLの初期文書が完全に読み込まれ解釈された時点で発生するイベント。<br>document.addEventListener('***', (event) => {console.log('loaded');}); → DOMが完全に読み込まれたときにログ'loaded'をコンソールに出力`},
{target:`.location`, content:`現在のURL。<br>代入で新しいURLへ移行するプロパティ。<br>document.***;`},
{target:`.outerHTML`, content:`要素のHTML全体を取得または設定するプロパティ。<br>element.***;`},
{target:`style`, content:`要素のインラインスタイルをCSS Style Declarationオブジェクトの形で返すHTML Elementの読み取り専用プロパティ。<br>このオブジェクトは、その要素のインラインのstyle属性で定義されている属性に値が割り当てられ、その要素のすべてのスタイルプロパティのリストが入っている。スタイル宣言は、nullまたは空文字列を設定することでリセットできる。<br>&lt;body ***='font-weight:bold'&gt;<br>element.***.backgroundColor = 'red';<br>element.***.cssText = 'width: 300px; position: relative; top: 250px; left: 250px';`},
{target:`.cssText`, content:`CSS Style Sheetスタイルルールの実際のテキストを返すCSS Ruleインターフェイスのプロパティ。<br>JavaScriptでCSS表記のままスタイルを指定できる。<br>element.style.*** = 'width: 300px; position: relative; top: 250px; left: 250px';`},
{target:`.search`, content:`URLのクエリ文字列を取得または設定するDOMプロパティ。<br>url.***;`},
{target:`selectedIndex`, content:`選択されているselect要素内のoption要素のインデックスを取得または設定するプロパティ。<br>const Index = document.getElementById('Select').***; → Select内の選択されたオプションのインデックスを返す`},
{target:`classList`, content:`要素の class 属性を返すプロパティ。<br>これを使用してクラスリストを操作できる。<br>element.***.add('newClass'); → elementにnewClassクラスを追加`},
{target:`setInterval()`, content:`定期的な処理の開始するタイマーメソッド。<br>***(func, delay);`},
{target:`clearInterval()`, content:`定期的な処理の停止するタイマーメソッド。<br>***(intervalID);`},
{target:`.alert()`, content:`ダイアログボックスを表示する。<br>***('Hello, World!'); → ダイアログに 'Hello, World!' を表示<br>window.***('Hello world!');`},
{target:`console.log()`, content:`メッセージをウェブコンソールに出力するメソッド。<br>***.***('Hello!'); → Hello!とコンソールに表示`},
{target:`console.time()`, content:`長い処理がどれくらいかかるかを計測することができるタイマーを起動するメソッド。<br>タイマーに固有の名前を付けると、10,000個までのタイマーを実行できる。同じ名前を引数としてconsole.timeEnd()を呼び出すと、タイマー開始からの経過時間がミリ秒単位で出力。<br>***.***('func');<br>***.***('func'); → 経過時間を出力`},
{target:`console.timeEnd()`, content:`console.time()の呼び出しで開始したタイマーを停止するメソッド。<br>停止させると、経過時間が自動的にウェブコンソールに停止した時刻を示すインジケーターと共に表示。<br>console.time('func');<br>***.***('func'); → 経過時間を出力`},
{target:`Date.now()`, content:`UTC(協定世界時) での1970年1月1日0時0分0秒から現在までの経過時間をミリ秒単位で返すメソッド。<br>startTime = ***.***();<br>endTime = ***.***();<br>endTime - startTime; → 処理時間`},
{target:`Audio()`, content:`新しいAudioオブジェクトを作成コンストラクタ。<br>new ***(url);<br>const audio = new ***('sound.mp3');<br>audio.play(); → sound.mp3を再生するAudioオブジェクトを作成`},
{target:`prompt()`, content:`ユーザーに質問を提示して入力を受け取る。<br>***('What's your name?'); → ダイアログで質問し、入力を取得`},
{target:`confirm()`, content:`ユーザーに確認を求める。<br>***('Are you sure?'); → ダイアログで確認し、OKかキャンセルを取得`},
{target:`Date`, content:`日付と時刻を表すオブジェクト。<br>new ***(); → 現在の日付と時刻のオブジェクトを作成`},
{target:`.toLocaleDateString()`, content:`ローカルの日付を文字列に変換するメソッド。<br>new Date().***(); → ローカルの日付を文字列に変換`},
{target:`.toLocaleTimeString()`, content:`ローカルの時刻を文字列に変換するメソッド。<br>new Date().***(); → ローカルの時刻を文字列に変換`},
{target:`Promise`, content:`非同期処理を扱うオブジェクト。<br>new ***((resolve, reject) => {...}); → ***インスタンスを作成`},
{target:`async`, content:`非同期関数の宣言修飾子。<br>*** function fetchData() {...} → 非同期関数を宣言`},
{target:`await`, content:`Promiseの解決を待つ。<br>const result = *** fetchData(); → 非同期処理の結果を待つ`},
{target:`.cookie`, content:`クッキーの操作のプロパティ。<br>document.*** = 'user=John'; → クッキーに 'user=John' を保存`},
{target:`fetch()`, content:`ネットワークリクエストを行うするメソッド。<br>***('https://api.example.com/data'); → リモートサーバーからデータを取得`},
{target:`.then()`, content:`最大2つの引数として、Promiseが成功した場合と失敗した場合のコールバック関数を取るメソッド。<br>fetch('...').***(response => {...}); → Promise の成功時に実行される処理を定義`},
{target:`localStorage`, content:`ローカルストレージにアクセスするプロパティ。<br>***.setItem('key', 'value'); → ローカルストレージにデータを保存`},
{target:`sessionStorage`, content:`セッションストレージにアクセスするプロパティ。<br>***.setItem('key', 'value'); → セッションストレージにデータを保存`},
{target:`.navigator`, content:`スクリプトを実行しているアプリケーションに関するメソッドとプロパティを持つNavigatorオブジェクトへの参照を返すプロパティ。<br>***.userAgent; → ブラウザのユーザーエージェントを取得`},
{target:`.history`, content:`ブラウザの履歴を制御のプロパティ。<br>window.***.back(); → ブラウザの履歴を一つ戻る`},
{target:`.screen`, content:`デバイスの画面に関する情報のプロパティ。<br>window.***.width; → 画面の幅を取得`},
{target:`RegExp`, content:`正規表現を表すオブジェクト。<br>const numCheck = new ***('\\d+'); → 数字にマッチする正規表現オブジェクト`},
{target:`.test()`, content:`正規表現に対して文字列をテストするメソッド。<br>regex.***('123'); → 正規表現に合致するかをテスト<br>/^[A-Z]*$/.***('ABCabc123'); → false（大文字のみ）<br>★/^[A-Za-z0-9]*$/.***('ABCabc123'); → true（大文字・小文字・数字のみ）`},
{target:`.match()`, content:`文字列を正規表現で検索するメソッド。<br>Hello, World!'.***(/World/); → 'World' にマッチする部分を取得`},
{target:`.charCodeAt()`, content:`文字列内の指定位置の文字コードを取得するメソッド。<br>'ABC'.charCodeAt(1); → 66 (文字'B'のUnicodeコード)`},
{target:`String.fromCharCode()`, content:`Unicodeコードから文字列を生成する静的メソッド。<br>***.***(65, 66, 67); → 'ABC'`},
{target:`.getDate()`, content:`日付オブジェクトから日を取得するメソッド。<br>new Date().***(); → 現在の日を取得`},
{target:`.getDay()`, content:`日付オブジェクトから曜日を取得するメソッド。<br>new Date().***(); → 現在の曜日を取得`},
{target:`.getFullYear()`, content:`日付オブジェクトから年を取得するメソッド。<br>new Date().***(); → 現在の年を取得`},
{target:`.getHours()`, content:`日付オブジェクトから時を取得するメソッド。<br>new Date().***(); → 現在の時を取得`},
{target:`.getMilliseconds()`, content:`日付オブジェクトからミリ秒を取得するメソッド。<br>new Date().***(); → 現在のミリ秒を取得`},
{target:`.getMinutes()`, content:`日付オブジェクトから分を取得するメソッド。<br>new Date().***(); → 現在の分を取得`},
{target:`.getMonth()`, content:`日付オブジェクトから月を取得するメソッド。<br>new Date().***(); → 現在の月を取得`},
{target:`.getSeconds()`, content:`日付オブジェクトから秒を取得するメソッド。<br>new Date().***(); → 現在の秒を取得`},
{target:`.getTime()`, content:`日付オブジェクトからエポックからのミリ秒を取得するメソッド。<br>new Date().***(); → 現在のエポックからのミリ秒を取得`},
{target:`.getTimezoneOffset()`, content:`タイムゾーンオフセットを取得するメソッド。<br>new Date().***(); → タイムゾーンのオフセットを取得`},
{target:`.getUTCDate()`, content:`UTC時刻から日を取得するメソッド。<br>new Date().***(); → 現在のUTC日を取得`},
{target:`.getUTCDay()`, content:`UTC時刻から曜日を取得するメソッド。<br>new Date().***(); → 現在のUTC曜日を取得`},
{target:`.getUTCFullYear()`, content:`UTC時刻から年を取得するメソッド。<br>new Date().***(); → 現在のUTC年を取得`},
{target:`.getUTCHours()`, content:`UTC時刻から時を取得するメソッド。<br>new Date().***(); → 現在のUTC時を取得`},
{target:`.getUTCMilliseconds()`, content:`UTC時刻からミリ秒を取得するメソッド。<br>new Date().***(); → 現在のUTCミリ秒を取得`},
{target:`.getUTCMinutes()`, content:`UTC時刻から分を取得するメソッド。<br>new Date().***(); → 現在のUTC分を取得`},
{target:`.getUTCMonth()`, content:`UTC時刻から月を取得するメソッド。<br>new Date().***(); → 現在のUTC月を取得`},
{target:`.getUTCSeconds()`, content:`UTC時刻から秒を取得するメソッド。<br>new Date().***(); → 現在のUTC秒を取得`},
{target:`.setDate()`, content:`日付オブジェクトの日を設定のメソッド。<br>let date = new Date().***(15); → dateの日を15に設定`},
{target:`.setFullYear()`, content:`日付オブジェクトの年を設定のメソッド。<br>let date = new Date().***(2023); → dateの年を2023に設定`},
{target:`.setHours()`, content:`日付オブジェクトの時を設定のメソッド。<br>let date = new Date().***(12); → dateの時を12に設定`},
{target:`.setMilliseconds()`, content:`日付オブジェクトのミリ秒を設定のメソッド。<br>let date = new Date().***(500); → dateのミリ秒を500に設定`},
{target:`.setMinutes()`, content:`日付オブジェクトの分を設定のメソッド。<br>let date = new Date().***(30); → dateの分を30に設定`},
{target:`.setMonth()`, content:`日付オブジェクトの月を設定のメソッド。<br>let date = new Date().***(5); → dateの月を5に設定`},
{target:`.setSeconds()`, content:`日付オブジェクトの秒を設定のメソッド。<br>let date = new Date().***(45); → dateの秒を45に設定`},
{target:`.setTime()`, content:`日付オブジェクトにエポックからのミリ秒を設定のメソッド。<br>let date = new Date().***(1609459200000); → dateを指定のエポックミリ秒に設定`},
{target:`.setUTCDate()`, content:`UTC時刻の日を設定のメソッド。<br>let date = new Date().***(10); → dateのUTC日を10に設定`},
{target:`.setUTCFullYear()`, content:`UTC時刻の年を設定のメソッド。<br>let date = new Date().***(2023); → dateのUTC年を2023に設定`},
{target:`.setUTCHours()`, content:`UTC時刻の時を設定のメソッド。<br>let date = new Date().***(8); → dateのUTC時を8に設定`},
{target:`.setUTCMilliseconds()`, content:`UTC時刻のミリ秒を設定のメソッド。<br>let date = new Date().***(200); → dateのUTCミリ秒を200に設定`},
{target:`.setUTCMinutes()`, content:`UTC時刻の分を設定のメソッド。<br>let date = new Date().***(45); → dateのUTC分を45に設定`},
{target:`.setUTCMonth()`, content:`UTC時刻の月を設定のメソッド。<br>let date = new Date().***(5); → dateのUTC月を5に設定`},
{target:`.setUTCSeconds()`, content:`UTC時刻の秒を設定のメソッド。<br>let date = new Date().***(30); → dateのUTC秒を30に設定`},
{target:`.toDateString()`, content:`日付オブジェクトを文字列に変換のメソッド。<br>let date = new Date().***(); → dateを文字列に変換`},
{target:`.toISOString()`, content:`日付オブジェクトをISO形式の文字列に変換のメソッド。<br>let date = new Date().***(); → dateをISO形式の文字列に変換`},
{target:`.toJSON()`, content:`日付オブジェクトをJSON形式の文字列に変換のメソッド。<br>let date = new Date().***(); → dateをJSON形式の文字列に変換`},
{target:`.toTimeString()`, content:`日付オブジェクトの時刻部分を文字列に変換のメソッド。<br>let date = new Date().***(); → dateの時刻部分を文字列に変換`},
{target:`.toUTCString()`, content:`日付オブジェクトをUTC時刻の文字列に変換のメソッド。<br>let date = new Date().***(); → dateをUTC時刻の文字列に変換`},
{target:`.apply()`, content:`this値を指定して関数を呼び出し、arguments は配列（または配列風オブジェクト）として提供するメソッド。<br>func.***(context, argsArray); → func を指定した context で実行<br>func(...arr) → func.***(null, arr)（スプレッド構文と同様）<br>Math.max.***(null, arr)`},
{target:`.call()`, content:`thisの値と、独立して提供された引数によって関数を呼び出すメソッド。<br>func.***(context, arg1, arg2); → funcを指定したcontextで実行`},
{target:`.name`, content:`関数オブジェクトの名前プロパティ。<br>function example() {}; example.***; → example`},
{target:`EvalError`, content:`評価中に発生するエラーオブジェクト。<br>throw new ***('Custom EvalError'); → 評価中のエラーを表すオブジェクト`},
{target:`URIError`, content:`URI操作関連のエラーオブジェクト。<br>throw new ***('Custom URIError'); → URI関連のエラーを表すオブジェクト`},
{target:`TypeError`, content:`型エラーオブジェクト。<br>throw new ***('Custom TypeError'); → 型に関連するエラーを表すオブジェクト`},
{target:`SyntaxError`, content:`構文エラーオブジェクト。<br>throw new ***('Custom SyntaxError'); → 構文に関連するエラーを表すオブジェクト`},
{target:`ReferenceError`, content:`参照エラーオブジェクト。<br>throw new ***('Custom ReferenceError'); → 変数やプロパティの参照に関連するエラーを表すオブジェクト`},
{target:`RangeError`, content:`範囲エラーオブジェクト。<br>throw new ***('Custom RangeError'); → 数値の範囲に関連するエラーを表すオブジェクト`},
{target:`encodeURIComponent()`, content:`URIコンポーネントの特殊文字をエンコードする関数。<br>***('#') → %23`},
]
